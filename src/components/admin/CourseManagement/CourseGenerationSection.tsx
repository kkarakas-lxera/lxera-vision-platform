import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';
import { cn } from '@/lib/utils';
import { Sparkles, Users, AlertCircle, Info } from 'lucide-react';
import { ActiveJobsDisplay } from './ActiveJobsDisplay';
import { EmployeeSelectionGrid } from './EmployeeSelectionGrid';

interface Employee {
  id: string;
  name: string;
  email: string;
  position: string;
  department: string;
  skills_gap_percentage: number;
  critical_gaps: number;
  moderate_gaps: number;
  last_course_date?: string;
  skills_last_analyzed?: string;
}

interface PendingOutline {
  plan_id: string;
  employee_id: string;
  employee_name: string;
  course_title: string;
  created_at: string;
  total_modules?: number;
}

export const CourseGenerationSection = () => {
  const { toast } = useToast();
  const { userProfile } = useAuth();
  const companyId = userProfile?.company_id;
  
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [filteredEmployees, setFilteredEmployees] = useState<Employee[]>([]);
  const [selectedEmployeeIds, setSelectedEmployeeIds] = useState<string[]>([]);
  const [departments, setDepartments] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [isGenerating, setIsGenerating] = useState(false);
  const [previewMode, setPreviewMode] = useState(false);
  const [pendingOutlines, setPendingOutlines] = useState<PendingOutline[]>([]);
  const [enableMultimedia, setEnableMultimedia] = useState(false);
  
  // Filters
  const [departmentFilter, setDepartmentFilter] = useState('all');
  const [skillsGapFilter, setSkillsGapFilter] = useState('all');

  useEffect(() => {
    if (companyId) {
      fetchEmployees();
      fetchPendingOutlines();
    }
  }, [companyId]);

  useEffect(() => {
    // Apply filters
    let filtered = [...employees];
    
    if (departmentFilter !== 'all') {
      filtered = filtered.filter(emp => emp.department === departmentFilter);
    }
    
    if (skillsGapFilter === 'critical') {
      filtered = filtered.filter(emp => emp.skills_gap_percentage >= 70);
    } else if (skillsGapFilter === 'high') {
      filtered = filtered.filter(emp => emp.skills_gap_percentage >= 40);
    }
    
    setFilteredEmployees(filtered);
  }, [employees, departmentFilter, skillsGapFilter]);

  const fetchPendingOutlines = async () => {
    if (!companyId) return;
    
    try {
      // First get employee IDs for this company
      const { data: companyEmployees, error: empError } = await supabase
        .from('employees')
        .select('id')
        .eq('company_id', companyId);
      
      if (empError) {
        console.error('Error fetching company employees:', empError);
        return;
      }
      
      const employeeIds = companyEmployees?.map(e => e.id) || [];
      
      if (employeeIds.length === 0) {
        setPendingOutlines([]);
        return;
      }
      
      // Fetch course outlines that don't have full courses generated yet
      // We'll check if they have modules generated by looking for cm_module_content entries
      const { data: outlines, error } = await supabase
        .from('cm_course_plans')
        .select(`
          plan_id,
          employee_id,
          employee_name,
          course_title,
          created_at,
          total_modules,
          course_structure
        `)
        .in('employee_id', employeeIds)  // Filter by company's employees
        .eq('status', 'completed')
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('Error fetching pending outlines:', error);
        return;
      }
      
      // For each outline, check if it has modules generated
      const outlineChecks = await Promise.all(
        (outlines || []).map(async (outline) => {
          const { data: moduleCount, error: moduleError } = await supabase
            .from('cm_module_content')
            .select('content_id', { count: 'exact', head: true })
            .eq('plan_id', outline.plan_id);
          
          if (moduleError) {
            console.error('Error checking modules for plan:', outline.plan_id, moduleError);
            return null;
          }
          
          // Only include outlines that don't have modules generated yet
          const hasModules = (moduleCount || 0) > 0;
          if (hasModules) {
            return null; // Exclude this outline
          }
          
          return {
            plan_id: outline.plan_id,
            employee_id: outline.employee_id,
            employee_name: outline.employee_name || 'Unknown',
            course_title: outline.course_title || 'Personalized Course',
            created_at: outline.created_at,
            total_modules: outline.total_modules || outline.course_structure?.modules?.length || 0
          };
        })
      );
      
      // Filter out null entries (plans that already have modules)
      const processedOutlines = outlineChecks.filter(outline => outline !== null);
      
      setPendingOutlines(processedOutlines);
    } catch (error) {
      console.error('Error fetching pending outlines:', error);
    }
  };

  const fetchEmployees = async () => {
    if (!companyId) return;
    
    try {
      setLoading(true);
      
      // First, get employees with active assignments to exclude them
      const { data: activeAssignments, error: assignmentsError } = await supabase
        .from('course_assignments')
        .select('employee_id')
        .in('status', ['assigned', 'in_progress']);
      
      if (assignmentsError) {
        console.error('Error fetching active assignments:', assignmentsError);
        // Continue with the main query even if this fails
      }
      
      const activeEmployeeIds = activeAssignments?.map(a => a.employee_id) || [];
      
      // Fetch employees with skills analysis data, excluding those with active assignments
      let query = supabase
        .from('employees')
        .select(`
          id,
          department,
          position,
          skills_last_analyzed,
          cv_analysis_data,
          current_position_id,
          users!inner (
            full_name,
            email
          ),
          employee_skills (
            skill_name,
            proficiency,
            source
          ),
          current_position:st_company_positions!employees_current_position_id_fkey (
            required_skills,
            nice_to_have_skills
          )
        `)
        .eq('company_id', companyId)
        .not('skills_last_analyzed', 'is', null);
      
      // Exclude employees with active assignments
      if (activeEmployeeIds.length > 0) {
        query = query.not('id', 'in', `(${activeEmployeeIds.map(id => `"${id}"`).join(',')})`);
      }
      
      const { data: employeesData, error } = await query;

      if (error) throw error;

      // Transform data for display
      const transformedEmployees = employeesData?.map(emp => {
        const employeeSkills = emp.employee_skills || [];
        const positionReqs = emp.current_position;
        
        // Calculate gaps from skills data
        let criticalGaps = 0;
        let moderateGaps = 0;
        let totalSkills = 0;
        let matchedSkills = 0;
        
        // Build a map of required skills
        const requiredSkillsMap = new Map();
        if (positionReqs?.required_skills) {
          positionReqs.required_skills.forEach((skill: any) => {
            requiredSkillsMap.set(skill.skill_name ? skill.skill_name.toLowerCase() : '', {
              required_level: skill.proficiency_level || 3,
              is_mandatory: skill.is_mandatory || false
            });
          });
        }
        if (positionReqs?.nice_to_have_skills) {
          positionReqs.nice_to_have_skills.forEach((skill: any) => {
            if (!requiredSkillsMap.has(skill.skill_name ? skill.skill_name.toLowerCase() : '')) {
              requiredSkillsMap.set(skill.skill_name ? skill.skill_name.toLowerCase() : '', {
                required_level: skill.proficiency_level || 2,
                is_mandatory: false
              });
            }
          });
        }
        
        // Calculate gaps by comparing employee skills with requirements
        employeeSkills.forEach((skill: any) => {
          const requirement = requiredSkillsMap.get(skill.skill_name ? skill.skill_name.toLowerCase() : '');
          if (requirement) {
            totalSkills++;
            const currentLevel = skill.proficiency || 0;
            const requiredLevel = Math.min(requirement.required_level, 3);
            
            if (currentLevel >= requiredLevel) {
              matchedSkills++;
            } else {
              const gap = requiredLevel - currentLevel;
              if (requirement.is_mandatory && gap >= 2) {
                criticalGaps++;
              } else if (gap >= 1) {
                moderateGaps++;
              }
            }
          }
        });
        
        // Check for missing mandatory skills
        requiredSkillsMap.forEach((requirement, skillName) => {
          if (requirement.is_mandatory) {
            const hasSkill = employeeSkills.some((s: any) => 
              (s.skill_name ? s.skill_name.toLowerCase() : '') === skillName
            );
            if (!hasSkill) {
              criticalGaps++;
              totalSkills++;
            }
          }
        });
        
        // Calculate match percentage
        const skillsMatch = totalSkills > 0 ? Math.round((matchedSkills / totalSkills) * 100) : 0;
        
        // Use CV analysis data if available for more accurate scoring
        const cvMatchScore = emp.cv_analysis_data?.skills_match_score;
        const finalMatchScore = cvMatchScore !== undefined ? cvMatchScore : skillsMatch;
        
        return {
          id: emp.id,
          name: emp.users?.full_name || 'Unknown',
          email: emp.users?.email || '',
          position: emp.position || 'N/A',
          department: emp.department || 'N/A',
          skills_gap_percentage: 100 - finalMatchScore,
          critical_gaps: criticalGaps,
          moderate_gaps: moderateGaps,
          skills_last_analyzed: emp.skills_last_analyzed,
        };
      }) || [];

      setEmployees(transformedEmployees);
      
      // Extract unique departments
      const uniqueDepts = [...new Set(transformedEmployees.map(e => e.department).filter(Boolean))];
      setDepartments(uniqueDepts.sort());
      
    } catch (error) {
      console.error('Error fetching employees:', error);
      toast({
        title: 'Error',
        description: 'Failed to load employees',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  const toggleEmployeeSelection = (employeeId: string) => {
    setSelectedEmployeeIds(prev => 
      prev.includes(employeeId)
        ? prev.filter(id => id !== employeeId)
        : [...prev, employeeId]
    );
  };

  const selectAll = () => {
    setSelectedEmployeeIds(filteredEmployees.map(emp => emp.id));
  };

  const clearSelection = () => {
    setSelectedEmployeeIds([]);
  };

  const handleGenerate = async () => {
    if (selectedEmployeeIds.length === 0) return;
    
    try {
      setIsGenerating(true);
      
      // Get current user ID for initiated_by field
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('User not authenticated');
      
      // Check if any selected employees only have outlines (no Module 1 yet)
      const outlineOnlyEmployees = pendingOutlines
        .filter(o => selectedEmployeeIds.includes(o.employee_id));
      const outlineOnlyEmployeeIds = outlineOnlyEmployees.map(o => o.employee_id);
      
      // Create a map of employee_id to plan_id for employees with outlines
      const employeePlanIdMap: Record<string, string> = {};
      outlineOnlyEmployees.forEach(o => {
        employeePlanIdMap[o.employee_id] = o.plan_id;
      });
      
      // Determine generation mode based on preview mode setting and employee state
      let generationMode: string;
      
      if (previewMode) {
        // Preview mode generates course outline only for approval, not modules
        generationMode = 'outline_only';
        console.log('🔍 Preview mode enabled - generating course outline for approval');
      } else if (outlineOnlyEmployeeIds.length > 0) {
        // If not preview mode but there are pending outlines, generate Module 1 for those employees
        generationMode = 'first_module';
        console.log('📋 Pending outlines detected - generating Module 1 for approval');
      } else {
        // Full generation for new employees when not in preview mode
        generationMode = 'full';
        console.log('🚀 Full generation mode - generating complete courses');
      }
      
      console.log('⚙️ Generation settings:', {
        previewMode,
        selectedEmployees: selectedEmployeeIds.length,
        pendingOutlines: outlineOnlyEmployeeIds.length,
        finalMode: generationMode,
        enableMultimedia
      });
      
      // Create a course generation job - backend will process this queue
      const { data: job, error: jobError } = await supabase
        .from('course_generation_jobs')
        .insert({
          company_id: companyId,
          initiated_by: user.id,
          total_employees: selectedEmployeeIds.length,
          employee_ids: selectedEmployeeIds,
          status: 'pending', // Worker will claim from pending status
          current_phase: 'Waiting for worker',
          progress_percentage: 0,
          successful_courses: 0,
          failed_courses: 0,
          generation_mode: generationMode,  // Store in dedicated column
          metadata: {
            priority: determinePriority(selectedEmployeeIds.length),
            estimated_duration_seconds: previewMode ? selectedEmployeeIds.length * 60 : selectedEmployeeIds.length * 300, // Preview is faster
            queued_at: new Date().toISOString(),
            is_preview: previewMode,
            is_approval: outlineOnlyEmployeeIds.length > 0,
            outline_employee_ids: outlineOnlyEmployeeIds,
            employee_plan_id_map: employeePlanIdMap,  // Map of employee_id to plan_id for first_module generation
            enable_multimedia: enableMultimedia  // Pass multimedia flag
          }
        })
        .select()
        .single();

      if (jobError) throw jobError;

      toast({
        title: previewMode ? 'Preview Generation Queued' : 'Course Generation Queued',
        description: previewMode 
          ? `Generating preview for ${selectedEmployeeIds.length} employee${selectedEmployeeIds.length > 1 ? 's' : ''}. You'll be able to review and approve before full generation.`
          : `Your request to generate courses for ${selectedEmployeeIds.length} employee${selectedEmployeeIds.length > 1 ? 's' : ''} has been queued. You'll see progress in the active jobs section shortly.`,
      });

      // Clear selection after queuing
      clearSelection();
      
      // The backend queue processor will:
      // 1. Pick up jobs with status 'queued'
      // 2. Change status to 'processing'
      // 3. Process employees in batches
      // 4. Update progress in real-time
      // 5. Handle failures and retries
      
    } catch (error) {
      console.error('Error queuing generation:', error);
      toast({
        title: 'Error',
        description: 'Failed to queue course generation',
        variant: 'destructive',
      });
    } finally {
      setIsGenerating(false);
    }
  };

  const determinePriority = (employeeCount: number): string => {
    // Smaller batches get higher priority for better user experience
    if (employeeCount <= 5) return 'high';
    if (employeeCount <= 20) return 'medium';
    return 'low';
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
          <p>Loading employees...</p>
        </div>
      </div>
    );
  }

  const hasAnalyzedEmployees = employees.length > 0;

  return (
    <div className="space-y-6">
      {/* Pending Outlines Indicator */}
      {pendingOutlines.length > 0 && (
        <div className="p-4 bg-amber-50 border border-amber-200 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <Badge variant="secondary" className="bg-amber-100 text-amber-800">
                  {pendingOutlines.length} Pending
                </Badge>
                <span className="text-sm font-medium text-amber-900">
                  Course Outlines Awaiting Approval
                </span>
              </div>
              <p className="text-sm text-amber-700">
                These employees completed their profiles and are waiting for course approval. Approve to generate Module 1 and start their learning journey.
              </p>
            </div>
            <Button 
              size="sm"
              variant="outline"
              className="border-amber-300 hover:bg-amber-100"
              onClick={() => {
                // Select these employees for Module 1 generation
                const outlineEmployeeIds = pendingOutlines.map(o => o.employee_id);
                setSelectedEmployeeIds(prev => {
                  const combined = [...new Set([...prev, ...outlineEmployeeIds])];
                  toast({
                    title: 'Employees Selected',
                    description: `Selected ${outlineEmployeeIds.length} employees for course approval and Module 1 generation`,
                  });
                  return combined;
                });
              }}
            >
              Approve & Generate Module 1
            </Button>
          </div>
        </div>
      )}
      
      {/* Active Jobs Section */}
      <ActiveJobsDisplay />
      
      {/* Generation Controls */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Generate New Courses</CardTitle>
              <CardDescription>
                Select employees to generate personalized AI courses based on their skills gaps
              </CardDescription>
            </div>
            <div className="flex items-center gap-4">
              <div className="flex items-center space-x-2">
                <Checkbox 
                  id="preview-mode"
                  checked={previewMode}
                  onCheckedChange={(checked) => setPreviewMode(checked as boolean)}
                />
                <label 
                  htmlFor="preview-mode" 
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                >
                  Preview mode
                </label>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Info className="h-4 w-4 text-muted-foreground hover:text-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent className="max-w-xs">
                      <p>
                        <strong>Preview Mode:</strong> Generates only the first module for admin review and approval. 
                        Full course generation continues after approval. Faster and cost-effective for testing content quality.
                      </p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              <div className="flex items-center space-x-2">
                <Checkbox 
                  id="enable-multimedia"
                  checked={enableMultimedia}
                  onCheckedChange={(checked) => setEnableMultimedia(checked as boolean)}
                  disabled={previewMode} // Disable multimedia for preview mode
                />
                <label 
                  htmlFor="enable-multimedia" 
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                >
                  Generate videos
                </label>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Info className="h-4 w-4 text-muted-foreground hover:text-foreground cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent className="max-w-xs">
                      <p>
                        <strong>AI Video Generation:</strong> Creates personalized video lessons with AI avatars 
                        and visual presentations. Increases engagement compared to text-only courses.
                      </p>
                      <p className="mt-1 text-xs text-muted-foreground">
                        Adds 10-15 min per module to processing time.
                      </p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              <Badge variant="outline">
                {selectedEmployeeIds.length} selected
              </Badge>
              <Button 
                onClick={handleGenerate}
                disabled={selectedEmployeeIds.length === 0 || isGenerating}
              >
                <Sparkles className="h-4 w-4 mr-2" />
                {previewMode ? 'Generate Preview' : 'Generate Courses'}
              </Button>
            </div>
          </div>
        </CardHeader>
        
        <CardContent>
          {!hasAnalyzedEmployees ? (
            <div className="text-center py-12">
              <AlertCircle className="h-12 w-12 text-yellow-500 mx-auto mb-4" />
              <p className="text-lg font-medium mb-2">No Analyzed Employees</p>
              <p className="text-muted-foreground mb-4">
                Analyze employee skills first to generate personalized courses
              </p>
              <Button
                variant="outline"
                onClick={() => window.location.href = '/dashboard/employees'}
              >
                Go to Employees
              </Button>
            </div>
          ) : (
            <>
              {/* Filters Bar */}
              <div className="flex items-center gap-2 mb-4">
                <Select value={departmentFilter} onValueChange={setDepartmentFilter}>
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="All Departments" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Departments</SelectItem>
                    {departments.map(dept => (
                      <SelectItem key={dept} value={dept}>{dept}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                
                <Select value={skillsGapFilter} onValueChange={setSkillsGapFilter}>
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="All Gaps" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Employees</SelectItem>
                    <SelectItem value="critical">Critical Gaps Only</SelectItem>
                    <SelectItem value="high">High Priority</SelectItem>
                  </SelectContent>
                </Select>
                
                <div className="ml-auto flex items-center gap-2">
                  <Button variant="outline" size="sm" onClick={selectAll}>
                    Select All Visible ({filteredEmployees.length})
                  </Button>
                  <Button variant="ghost" size="sm" onClick={clearSelection}>
                    Clear Selection
                  </Button>
                </div>
              </div>
              
              {/* Employee Selection Grid */}
              {filteredEmployees.length > 0 ? (
                <EmployeeSelectionGrid 
                  employees={filteredEmployees}
                  selectedIds={selectedEmployeeIds}
                  onToggleSelect={toggleEmployeeSelection}
                />
              ) : (
                <div className="text-center py-8 text-muted-foreground">
                  <Users className="h-12 w-12 mx-auto mb-4 opacity-50" />
                  <p>No employees match the selected filters</p>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </div>
  );
};